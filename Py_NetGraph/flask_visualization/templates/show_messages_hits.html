<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¤¾äº¤å…³ç³»å¯è§†åŒ– ğŸ”¹ ç”¨æˆ·ä¼ æ’­æ€§åˆ†æ</title>
    <script src="{{ url_for('static', filename='echarts.min.js') }}"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <h1>ç”¨æˆ· HITS å½±å“åŠ›åˆ†æ</h1>
    <div id="top10-container">
        <h2>HITS Top 10 ç”¨æˆ·</h2>
        <label for="sort-method">æ’åºæ–¹å¼:</label>
        <select id="sort-method">
            <option value="authority">Authority</option>
            <option value="hub">Hub</option>
        </select>
        <label for="size-method">èŠ‚ç‚¹å¤§å°:</label>
        <select id="size-method">
            <option value="authority">Authority</option>
            <option value="hub">Hub</option>
        </select>
        <ul id="top10-list"></ul>
    </div>
    <div id="chart" style="width: 100%; height: 600px;"></div>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            let chart = echarts.init(document.getElementById("chart"));
            let sortMethod = document.getElementById("sort-method");
            let sizeMethod = document.getElementById("size-method");
            let scaleFactor = 150;

            function updateTop10(data, method) {
                let top10Users = [...data.nodes]
                    .sort((a, b) => b[method] - a[method])
                    .slice(0, 10);

                let top10List = document.getElementById("top10-list");
                top10List.innerHTML = top10Users
                    .map(user => `<li>${user.username} - ${method.charAt(0).toUpperCase() + method.slice(1)}: ${user[method].toFixed(3)}</li>`)
                    .join("");
            }

            function updateChart(data) {
                let selectedSizeMethod = sizeMethod.value;
                let option = {
                    title: {
                        text: "ç”¨æˆ· HITS å½±å“åŠ›åˆ†æ",
                        left: "center",
                        textStyle: { fontSize: 20 }
                    },
                    tooltip: {
                        trigger: "item",
                        formatter: function (params) {
                            if (params.dataType === "node") {
                                return `ç”¨æˆ·: <strong>${params.data.username}</strong><br>Authority: ${params.data.authority.toFixed(3)}<br>Hub: ${params.data.hub.toFixed(3)}`;
                            }
                            return `å‘é€: <strong>${params.data.source}</strong> â†’ æ¥æ”¶: <strong>${params.data.target}</strong><br>æ¶ˆæ¯æ•°: ${params.data.weight}`;
                        }
                    },
                    legend: {
                        orient: "vertical",
                        left: "left",
                        data: ["é«˜ Authority", "é«˜ Hub", "å…¶ä»–"]
                    },
                    series: [{
                        type: "graph",
                        layout: "force",
                        roam: true,
                        draggable: true,
                        force: {
                            repulsion: 180,
                            edgeLength: [60, 220]
                        },
                        toolbox: {
                            show: true,
                            feature: {
                                saveAsImage: { title: "ä¿å­˜å›¾ç‰‡" },
                                dataZoom: { title: "ç¼©æ”¾" },
                                restore: { title: "è¿˜åŸ" }
                            },
                            right: "5%"
                        },
                        label: {
                            show: true,
                            position: "right",
                            formatter: "{b}"
                        },
                        edgeSymbol: ["none", "arrow"],
                        edgeSymbolSize: [0, 8],
                        data: data.nodes.map(n => {
    let category;
    if (n.authority > n.hub) {
        category = { name: "é«˜ Authority", color: "#e74c3c" };
    } else if (n.hub > n.authority) {
        category = { name: "é«˜ Hub", color: "#f39c12" };
    } else {
        category = { name: "å…¶ä»–", color: "#3498db" };
    }
    return {
        name: n.username,
        id: n.id,
        symbolSize: Math.max(n[selectedSizeMethod] * scaleFactor, 10),  // æœ€å°å€¼ 10
        itemStyle: { color: category.color },
        category: category.name,
        username: n.username,
        authority: n.authority,
        hub: n.hub
    };
}),

                        edges: data.edges.map(e => ({
                            source: e.source.toString(),
                            target: e.target.toString(),
                            weight: e.weight,
                            lineStyle: {
                                color: e.source === e.target ? '#BDC3C7' : (e.source > e.target ? '#adcffa' : '#ffd2a8'),
                                width: 2.0,
                                curveness: 0.05
                            }
                        })),
                        categories: [
                            { name: "é«˜ Authority", color: "#e74c3c" },
                            { name: "é«˜ Hub", color: "#f39c12" },
                            { name: "å…¶ä»–", color: "#3498db" }
                        ]
                    }]
                };
                chart.setOption(option);
            }

            fetch("/api/messages_hits")
                .then(response => response.json())
                .then(data => {
                    updateTop10(data, sortMethod.value);
                    updateChart(data);
                    sortMethod.addEventListener("change", () => updateTop10(data, sortMethod.value));
                    sizeMethod.addEventListener("change", () => updateChart(data));
                })
                .catch(error => console.error("æ•°æ®åŠ è½½å¤±è´¥:", error));
        });
    </script>
</body>
</html>
